<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>4PL System Limit Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-50 text-gray-900">
  <div id="root" class="p-6"></div>

  <script type="text/babel" data-presets="react">
    const { useMemo, useState, useId } = React;

    function logspace(start, stop, num) {
      const arr = new Array(num);
      const logStart = Math.log10(start);
      const logStop = Math.log10(stop);
      for (let i = 0; i < num; i++) {
        const tt = i / (num - 1);
        arr[i] = Math.pow(10, logStart + tt * (logStop - logStart));
      }
      return arr;
    }

    function fourPL(x, a, b, c, d) {
      return a + (d - a) / (1 + Math.pow(c / x, b));
    }

    function linePath(xs, ys, x2px, y2px) {
      let d = "";
      for (let i = 0; i < xs.length; i++) {
        const X = x2px(xs[i]);
        const Y = y2px(ys[i]);
        d += i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`;
      }
      return d;
    }

    function makeX2pxLocal(xmin, xmax, plotW) {
      const logMin = Math.log10(xmin);
      const logMax = Math.log10(xmax);
      return (x) => {
        const v = (Math.log10(x) - logMin) / (logMax - logMin);
        return v * plotW;
      };
    }

    function makeY2pxLogLocal(yminPos, ymaxPos, plotH) {
      const lo = Math.log10(yminPos);
      const hi = Math.log10(ymaxPos);
      return (y) => {
        const yy = Math.max(y, yminPos);
        const v = (Math.log10(yy) - lo) / (hi - lo);
        return plotH - v * plotH;
      };
    }

    function rectForXSpanLocal(xStart, xEnd, x2px, plotH, fill, opacity) {
      if (!isFinite(xStart) || !isFinite(xEnd) || xEnd <= xStart) return null;
      const X1 = x2px(xStart);
      const X2 = x2px(xEnd);
      const x = Math.min(X1, X2);
      const w = Math.max(0, Math.abs(X2 - X1));
      return <rect x={x} y={0} width={w} height={plotH} fill={fill} opacity={opacity} />;
    }

    function clamp(y, lo, hi) {
      return Math.min(Math.max(y, lo), hi);
    }

    function abundanceFractionFromT(t) {
      const minF = 1e-5;
      const maxF = 0.5;
      const logMin = Math.log10(minF);
      const logMax = Math.log10(maxF);
      return Math.pow(10, logMin + t * (logMax - logMin));
    }

    function contiguousSpans(xs, mask) {
      const spans = [];
      let inRun = false;
      let runStart = 0;

      for (let i = 0; i < mask.length; i++) {
        if (mask[i] && !inRun) {
          inRun = true;
          runStart = i;
        }
        if ((!mask[i] || i === mask.length - 1) && inRun) {
          const endIdx = mask[i] ? i : i - 1;
          const xStart = xs[Math.max(0, runStart)];
          const xEnd = xs[Math.min(xs.length - 1, endIdx)];
          if (isFinite(xStart) && isFinite(xEnd) && xEnd > xStart) spans.push([xStart, xEnd]);
          inRun = false;
        }
      }
      return spans;
    }

    function fmtSci(x, sig = 2) {
      if (!isFinite(x) || x <= 0) return String(x);
      const e = Math.floor(Math.log10(x));
      const m = x / Math.pow(10, e);
      return `${m.toFixed(sig)}e${e >= 0 ? "+" : ""}${e}`;
    }

    function fmtPct(frac) {
      const pct = frac * 100;
      if (pct >= 1) return `${pct.toFixed(1)}%`;
      if (pct >= 0.01) return `${pct.toFixed(3)}%`;
      return `${pct.toExponential(2)}%`;
    }

    function nirGainFromT(t) {
      const minG = 1 / 500;
      const maxG = 1 / 2;
      const logMin = Math.log10(minG);
      const logMax = Math.log10(maxG);
      return Math.pow(10, logMin + t * (logMax - logMin));
    }

    function xHalfDecadesFromT(t) {
      return 0.8 + t * (3.0 - 0.8);
    }

    const WIDTH = 520;
    const HEIGHT = 380;
    const PAD = 16;

    function Panel({
      title,
      subtitle,
      xs,
      yTrue,
      yObs,
      spansBuilder,
      yMinDet,
      yMaxSys,
      xAxisLabel,
      yAxisLabel,
      xMin,
      xMax,
      yDomainLog
    }) {
      const clipId = useId();

      const plotX = PAD + 44;      // extra room for y-axis label
      const plotY = PAD + 6;
      const plotW = WIDTH - (PAD + 44) - PAD;
      const plotH = HEIGHT - (PAD + 34) - PAD; // extra room for x-axis label

      const x2px = useMemo(() => makeX2pxLocal(xMin, xMax, plotW), [xMin, xMax, plotW]);
      const y2px = useMemo(
        () => makeY2pxLogLocal(yDomainLog.yMinPos, yDomainLog.yMaxPos, plotH),
        [yDomainLog, plotH]
      );

      const truePath = useMemo(() => linePath(xs, yTrue, x2px, y2px), [xs, yTrue, x2px, y2px]);
      const obsPath = useMemo(() => linePath(xs, yObs, x2px, y2px), [xs, yObs, x2px, y2px]);

      return (
        <div className="relative bg-white rounded-2xl shadow p-3">
          <div className="mb-2">
            <div className="text-sm font-medium">{title}</div>
            {subtitle ? <div className="text-xs text-gray-600 mt-0.5">{subtitle}</div> : null}
          </div>

          <svg
            viewBox={`0 0 ${WIDTH} ${HEIGHT}`}
            width="100%"
            height={HEIGHT}
            className="w-full rounded-xl block"
            preserveAspectRatio="xMidYMid meet"
          >
            <defs>
              <clipPath id={clipId} clipPathUnits="userSpaceOnUse">
                <rect x={0} y={0} width={plotW} height={plotH} rx="8" ry="8" />
              </clipPath>
            </defs>

            <g transform={`translate(${plotX},${plotY})`}>

              {/* Y-axis label */}
              <text
                x={-36}
                y={plotH / 2}
                textAnchor="middle"
                fontSize="14"
                fill="currentColor"
                opacity="0.80"
                transform={`rotate(-90, ${-36}, ${plotH / 2})`}
              >
                {yAxisLabel}
              </text>

              <g clipPath={`url(#${clipId})`}>
                {spansBuilder({ x2px, y2px, plotW, plotH })}

                {/* Detection floor */}
                <line
                  x1={0}
                  x2={plotW}
                  y1={y2px(yMinDet)}
                  y2={y2px(yMinDet)}
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeDasharray="2 6"
                  strokeLinecap="butt"
                  opacity="0.8"
                />

                {/* Burnout threshold */}
                <line
                  x1={0}
                  x2={plotW}
                  y1={y2px(yMaxSys)}
                  y2={y2px(yMaxSys)}
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeDasharray="6 6"
                  strokeLinecap="butt"
                />

                {/* True response */}
                <path
                  d={truePath}
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeDasharray="4 4"
                  strokeLinecap="butt"
                />

                {/* Observed response (clipped) */}
                <path
                  d={obsPath}
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="3"
                  strokeLinecap="butt"
                />
              </g>

              {/* X-axis label */}
              <text
                x={plotW / 2}
                y={plotH + 30}
                textAnchor="middle"
                fontSize="14"
                fill="currentColor"
                opacity="0.80"
              >
                {xAxisLabel}
              </text>
            </g>
          </svg>
        </div>
      );
    }

    function Interactive4PLWidget() {
      const [t, setT] = useState(0.62);

      // Blue band slope control
      const fixedMinSlope = 0.10;
      const [maxSlope, setMaxSlope] = useState(1.15);

      // Global system ceiling (absolute units)
      const [burnoutY, setBurnoutY] = useState(0.90);

      // X span and NIR gain
      const [xSpanT, setXSpanT] = useState(0.50);
      const [nirGainT, setNirGainT] = useState(0.42);

      // 4PL shape parameters
      const b = 1.35;
      const c = 1e-2;

      const abundanceFrac = useMemo(() => abundanceFractionFromT(t), [t]);
      const abundancePctStr = useMemo(() => fmtPct(abundanceFrac), [abundanceFrac]);

      // Constant baseline (fixes the "signal too high" caused by baseline growing with loading)
      const a0 = 0.03;
      const d0 = 1.5;

      // X domain
      const xCenterLog10 = -0.5;
      const xHalfDec = useMemo(() => xHalfDecadesFromT(xSpanT), [xSpanT]);
      const xMin = useMemo(() => Math.pow(10, xCenterLog10 - xHalfDec), [xHalfDec]);
      const xMax = useMemo(() => Math.pow(10, xCenterLog10 + xHalfDec), [xHalfDec]);

      const xs = useMemo(() => logspace(xMin, xMax, 700), [xMin, xMax]);

      const slopeBand = useMemo(() => {
        const mx = Math.max(maxSlope, fixedMinSlope + 0.01);
        return { min: fixedMinSlope, max: mx };
      }, [maxSlope]);

      const nirTargetGain = useMemo(() => nirGainFromT(nirGainT), [nirGainT]);
      const irTargetGain = useMemo(() => nirTargetGain * nirTargetGain, [nirTargetGain]);

      const channels = useMemo(
        () => [
          {
            key: "chemi",
            title: "Chemiluminescence",
            subtitle: "Highest effective sensitivity: best low-end, most likely to saturate early",
            targetGain: 1.0,
            signalGain: 1.0,
            yMinDet: 0.03,
          },
          {
            key: "nir",
            title: "NIR",
            subtitle: "Right-shift set by NIR targetGain slider",
            targetGain: nirTargetGain,
            signalGain: 1.0,
            yMinDet: 0.03,
          },
          {
            key: "ir",
            title: "IR",
            subtitle: "IR targetGain = (NIR targetGain)²",
            targetGain: irTargetGain,
            signalGain: 1.0,
            yMinDet: 0.03,
          },
        ],
        [nirTargetGain, irTargetGain]
      );

      // Y domain (absolute units)
      const yDomainLog = useMemo(() => ({ yMinPos: 0.02, yMaxPos: 2.5 }), []);

      const panels = useMemo(() => {
        const EPS = 1e-12;

        return channels.map((ch) => {
          // Constant baseline (no dependence on xTotal)
          const yBase = xs.map(() => a0);

          // Absolute 4PL response (includes baseline)
          const yTrue = xs.map((xTotal, i) => {
            const xTargetEff = Math.max(1e-16, abundanceFrac * xTotal * ch.targetGain);
            const a = yBase[i];
            const d = d0;

            const yRaw = fourPL(xTargetEff, a, b, c, d);
            const yScaled = a + (yRaw - a) * ch.signalGain;
            return yScaled;
          });

          // Observed response (floor + burnout clipping) in absolute units
          const yObs = yTrue.map((y) => clamp(y, ch.yMinDet, burnoutY));

          // Burnout onset
          const idxBurn = yTrue.findIndex((y) => y >= burnoutY);
          const xCutBurn = idxBurn === -1 ? Infinity : xs[Math.max(0, idxBurn)];

          // Slope computed on net signal (absolute minus baseline) to define "linearity"
          const logX = xs.map((x) => Math.log10(x));
          const yNet = yTrue.map((y, i) => Math.max(EPS, y - yBase[i]));
          const logY = yNet.map((yn) => Math.log10(yn));

          const slope = new Array(xs.length).fill(NaN);
          for (let i = 1; i < xs.length - 1; i++) {
            const dLogX = logX[i + 1] - logX[i - 1];
            if (Math.abs(dLogX) < 1e-12) continue;
            slope[i] = (logY[i + 1] - logY[i - 1]) / dLogX;
          }
          slope[0] = slope[1];
          slope[slope.length - 1] = slope[slope.length - 2];

          const isBlue = xs.map((xTotal, i) => {
            const withinSignal = (yTrue[i] >= ch.yMinDet) && (yTrue[i] < burnoutY);
            const withinSlope = (slope[i] >= slopeBand.min) && (slope[i] <= slopeBand.max);
            const beforeBurn = !(xCutBurn < Infinity && xTotal >= xCutBurn);
            return withinSignal && withinSlope && beforeBurn;
          });

          const blueSpans = contiguousSpans(xs, isBlue);

          const spansBuilder = ({ x2px, y2px, plotW, plotH }) => (
            <>
              {/* Below detection floor shading */}
              <rect
                x={0}
                y={y2px(ch.yMinDet)}
                width={plotW}
                height={y2px(yDomainLog.yMinPos) - y2px(ch.yMinDet)}
                fill="currentColor"
                opacity="0.06"
              />

              {/* Blue regions */}
              {blueSpans.map(([xA, xB], k) => (
                <React.Fragment key={k}>
                  {rectForXSpanLocal(xA, xB, x2px, plotH, "#66b3ff", 0.18)}
                </React.Fragment>
              ))}

              {/* Red: burnout from onset to xMax */}
              {xCutBurn < xMax &&
                rectForXSpanLocal(
                  Math.max(xCutBurn, xMin),
                  xMax,
                  x2px,
                  plotH,
                  "#ff9999",
                  0.25
                )}
            </>
          );

          return { ch, yTrue, yObs, spansBuilder };
        });
      }, [
        channels,
        xs,
        a0,
        d0,
        b,
        c,
        abundanceFrac,
        slopeBand,
        burnoutY,
        xMin,
        xMax,
        yDomainLog
      ]);

      const labelForAbundance = useMemo(() => {
        if (abundanceFrac >= 1e-2) return "Very abundant target (housekeeper / overexpressed)";
        if (abundanceFrac >= 1e-4) return "Moderate abundance target";
        return "Very low abundance target (eg phospho)";
      }, [abundanceFrac]);

      // Units (edit these to match your mental model)
      const xUnit = "relative loading (arb. units)";
      const yUnit = "signal (arb. units)";

      const xAxisLabel = useMemo(() => {
        return `total sample loading, ${xUnit} (range: ${fmtSci(xMin, 1)} to ${fmtSci(xMax, 1)})`;
      }, [xMin, xMax]);

      const yAxisLabel = useMemo(() => {
        return `measured signal, ${yUnit} (log scale)`;
      }, [yUnit]);

      return (
        <div className="w-full min-h-screen bg-gray-50 text-gray-900 p-4 text-base">
          <div className="max-w-[1600px] mx-auto">
            <h1 className="text-2xl font-semibold mb-3">Interactive Burnout and Sensitivity Visualiser</h1>

            <p className="text-sm mb-4 text-gray-700">
              Log y-axis. Curves are absolute 4PL responses including a constant baseline (a0), so "no target" sits at a0.
              Blue is computed using log-log slope of the baseline-subtracted signal (y - a0), but the plotted curves remain absolute.
              Red is burnout (do not use) from the onset to the right edge.
            </p>

            <div className="bg-white rounded-2xl shadow p-4 mb-6">
              <div className="grid grid-cols-12 gap-4 items-center">
                <div className="col-span-12 lg:col-span-6">
                  <div className="text-sm font-medium mb-2">Target fraction inside the loaded sample</div>
                  <input
                    type="range"
                    min={0}
                    max={1}
                    step={0.005}
                    value={t}
                    onChange={(e) => setT(parseFloat(e.target.value))}
                    className="w-full"
                  />
                  <div className="mt-2 text-sm text-gray-700">
                    <span className="font-mono">{abundancePctStr}</span>
                    <span className="text-gray-600">  </span>
                    <span className="text-gray-600">Example: </span>
                    <span className="font-medium">{labelForAbundance}</span>
                  </div>
                  <div className="mt-2 text-xs text-gray-600">
                    a0 baseline (constant): <span className="font-mono">{a0.toFixed(3)}</span>, 4PL c: <span className="font-mono">{fmtSci(c, 2)}</span>, b: <span className="font-mono">{b.toFixed(2)}</span>
                  </div>
                </div>

                <div className="col-span-12 lg:col-span-6">
                  <div className="text-sm font-medium mb-2">Linearity band (blue): expand to the left</div>
                  <input
                    type="range"
                    min={0.20}
                    max={1.34}
                    step={0.005}
                    value={maxSlope}
                    onChange={(e) => setMaxSlope(parseFloat(e.target.value))}
                    className="w-full"
                  />
                  <div className="mt-2 text-sm text-gray-700">
                    Slope band: <span className="font-mono">{slopeBand.min.toFixed(2)} to {slopeBand.max.toFixed(2)}</span>
                    <span className="text-gray-600"> (higher max lets blue extend left)</span>
                  </div>
                </div>

                <div className="col-span-12 lg:col-span-6">
                  <div className="text-sm font-medium mb-2">Burnout threshold (all channels)</div>
                  <input
                    type="range"
                    min={0.20}
                    max={1.40}
                    step={0.01}
                    value={burnoutY}
                    onChange={(e) => setBurnoutY(parseFloat(e.target.value))}
                    className="w-full"
                  />
                  <div className="mt-2 text-sm text-gray-700">
                    Burnout y: <span className="font-mono">{burnoutY.toFixed(2)}</span> <span className="text-gray-600">{yUnit}</span>
                  </div>
                </div>

                <div className="col-span-12 lg:col-span-6">
                  <div className="text-sm font-medium mb-2">X-axis span (all channels)</div>
                  <input
                    type="range"
                    min={0}
                    max={1}
                    step={0.005}
                    value={xSpanT}
                    onChange={(e) => setXSpanT(parseFloat(e.target.value))}
                    className="w-full"
                  />
                  <div className="mt-2 text-sm text-gray-700">
                    X range: <span className="font-mono">{fmtSci(xMin, 1)} to {fmtSci(xMax, 1)}</span>
                    <span className="text-gray-600"> {xUnit}</span>
                  </div>
                </div>

                <div className="col-span-12">
                  <div className="text-sm font-medium mb-2">NIR targetGain (IR = NIR²)</div>
                  <input
                    type="range"
                    min={0}
                    max={1}
                    step={0.005}
                    value={nirGainT}
                    onChange={(e) => setNirGainT(parseFloat(e.target.value))}
                    className="w-full"
                  />
                  <div className="mt-2 text-sm text-gray-700">
                    NIR targetGain: <span className="font-mono">{fmtSci(nirTargetGain, 2)}</span>
                    <span className="text-gray-600">  </span>
                    IR targetGain: <span className="font-mono">{fmtSci(irTargetGain, 2)}</span>
                    <span className="text-gray-600">  </span>
                    (Chemi targetGain is 1.00)
                  </div>
                </div>
              </div>
            </div>

            <div className="grid grid-cols-12 gap-6 items-stretch">
              <div className="col-span-12 lg:col-span-3">
                <div className="bg-white rounded-2xl shadow p-4 h-full">
                  <div className="text-sm font-medium mb-3">Legend</div>
                  <ul className="space-y-3 text-sm">
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "rgba(0,0,0,0.06)" }} />
                      Below detection floor (not quantifiable)
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "#66b3ff", opacity: 0.18 }} />
                      Slope-based linear region (computed from baseline-subtracted signal)
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "#ff9999", opacity: 0.25 }} />
                      Burnout region (do not use)
                    </li>
                  </ul>

                  <div className="mt-5 text-xs text-gray-600 leading-relaxed">
                    X-axis: {xUnit}. Y-axis: {yUnit} on a log scale. Baseline is constant (a0), so increasing total loading
                    does not artificially push the whole curve upward when target is absent.
                  </div>
                </div>
              </div>

              <div className="col-span-12 lg:col-span-9 grid grid-cols-1 xl:grid-cols-3 gap-6">
                {panels.map((p) => (
                  <Panel
                    key={p.ch.key}
                    title={p.ch.title}
                    subtitle={`${p.ch.subtitle}  (targetGain=${fmtSci(p.ch.targetGain, 2)})`}
                    xs={xs}
                    yTrue={p.yTrue}
                    yObs={p.yObs}
                    spansBuilder={p.spansBuilder}
                    yMinDet={p.ch.yMinDet}
                    yMaxSys={burnoutY}
                    xAxisLabel={xAxisLabel}
                    yAxisLabel={yAxisLabel}
                    xMin={xMin}
                    xMax={xMax}
                    yDomainLog={yDomainLog}
                  />
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<Interactive4PLWidget />);
  </script>
</body>
</html>
