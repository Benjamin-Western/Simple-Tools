<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>4PL System Limit Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- React + ReactDOM + Babel + Tailwind (CDN) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-50 text-gray-900">
  <div id="root" class="p-6"></div>

  <script type="text/babel" data-presets="react">
    const { useMemo, useState, useId } = React;

    /* --------------------- Helpers --------------------- */
    function logspace(start, stop, num) {
      const arr = new Array(num);
      const logStart = Math.log10(start);
      const logStop = Math.log10(stop);
      for (let i = 0; i < num; i++) {
        const t = i / (num - 1);
        arr[i] = Math.pow(10, logStart + t * (logStop - logStart));
      }
      return arr;
    }

    function fourPL(x, a, b, c, d) {
      return a + (d - a) / (1 + Math.pow(c / x, b));
    }

    function linePath(xs, ys, x2px, y2px) {
      let d = "";
      for (let i = 0; i < xs.length; i++) {
        const X = x2px(xs[i]);
        const Y = y2px(ys[i]);
        d += i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`;
      }
      return d;
    }

    function makeX2pxLocal(xmin, xmax, plotW) {
      const logMin = Math.log10(xmin);
      const logMax = Math.log10(xmax);
      return (x) => {
        const v = (Math.log10(x) - logMin) / (logMax - logMin);
        return v * plotW;
      };
    }

    function makeY2pxLocal(ymin, ymax, plotH) {
      return (y) => {
        const v = (y - ymin) / (ymax - ymin);
        return plotH - v * plotH;
      };
    }

    function rectForXSpanLocal(xStart, xEnd, x2px, plotH, fill, opacity) {
      if (!isFinite(xStart) || !isFinite(xEnd) || xEnd <= xStart) return null;
      const X1 = x2px(xStart);
      const X2 = x2px(xEnd);
      const x = Math.min(X1, X2);
      const w = Math.max(0, Math.abs(X2 - X1));
      return <rect x={x} y={0} width={w} height={plotH} fill={fill} opacity={opacity} />;
    }

    function clamp(y, lo, hi) {
      return Math.min(Math.max(y, lo), hi);
    }

    // Slider t in [0,1] -> target abundance in % (log scale). Internally allows >100%
    function abundancePercentFromT(t) {
      const minP = 0.001;
      const maxP = 1000; // internal "super abundant" region
      const logMin = Math.log10(minP);
      const logMax = Math.log10(maxP);
      return Math.pow(10, logMin + t * (logMax - logMin));
    }

    /* --------------------- Panel --------------------- */
    const WIDTH = 520;
    const HEIGHT = 360;
    const PAD = 16;

    function Panel({ title, subtitle, pathsData, spansBuilder, yMinDet, yMaxSys, xAxisLabel }) {
      const clipId = useId();

      const plotX = PAD;
      const plotY = PAD;
      const plotW = WIDTH - 2 * PAD;
      const plotH = HEIGHT - 2 * PAD;

      const x2px = useMemo(() => makeX2pxLocal(1e-2, 1e1, plotW), [plotW]);
      const y2px = useMemo(() => makeY2pxLocal(0, 1.2, plotH), [plotH]);

      const truePath = useMemo(
        () => linePath(pathsData.xs, pathsData.yTrue, x2px, y2px),
        [pathsData, x2px, y2px]
      );
      const obsPath = useMemo(
        () => linePath(pathsData.xs, pathsData.yObs, x2px, y2px),
        [pathsData, x2px, y2px]
      );

      return (
        <div className="relative bg-white rounded-2xl shadow p-3">
          <div className="mb-2">
            <div className="text-sm font-medium">{title}</div>
            {subtitle ? <div className="text-xs text-gray-600 mt-0.5">{subtitle}</div> : null}
          </div>

          <svg
            viewBox={`0 0 ${WIDTH} ${HEIGHT}`}
            width="100%"
            height={HEIGHT}
            className="w-full rounded-xl block"
            preserveAspectRatio="xMidYMid meet"
          >
            <defs>
              <clipPath id={clipId} clipPathUnits="userSpaceOnUse">
                <rect x={0} y={0} width={plotW} height={plotH} rx="8" ry="8" />
              </clipPath>
            </defs>

            <g transform={`translate(${plotX},${plotY})`}>
              <g clipPath={`url(#${clipId})`}>
                {spansBuilder({ x2px, y2px, plotW, plotH })}

                {/* detection floor */}
                <line
                  x1={0}
                  x2={plotW}
                  y1={y2px(yMinDet)}
                  y2={y2px(yMinDet)}
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeDasharray="2 6"
                  strokeLinecap="butt"
                  opacity="0.8"
                />

                {/* burnout threshold */}
                <line
                  x1={0}
                  x2={plotW}
                  y1={y2px(yMaxSys)}
                  y2={y2px(yMaxSys)}
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeDasharray="6 6"
                  strokeLinecap="butt"
                />

                {/* curves */}
                <path
                  d={truePath}
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeDasharray="4 4"
                  strokeLinecap="butt"
                />
                <path
                  d={obsPath}
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="3"
                  strokeLinecap="butt"
                />
              </g>

              {/* x-axis title (outside clip so it stays visible) */}
              <text
                x={plotW / 2}
                y={plotH + 30}
                textAnchor="middle"
                fontSize="16"
                fill="currentColor"
                opacity="0.80"
              >
                {xAxisLabel}
              </text>

              <rect
                x={0}
                y={0}
                width={plotW}
                height={plotH}
                fill="none"
                stroke="transparent"
                rx="8"
                ry="8"
              />
            </g>
          </svg>
        </div>
      );
    }

    /* --------------------- App --------------------- */
    function Interactive4PLWidget() {
      const [t, setT] = useState(0.78);

      // Base 4PL shape
      const b = 1.4;
      const c = 0.35;

      // x range
      const xMin = 1e-2;
      const xMax = 1e1;

      // "validated linear" band centered around c
      const linFactor = 3.0;
      const xLow = c / linFactor;
      const xHigh = c * linFactor;

      // UI abundance in % (internal can exceed 100)
      const abundancePct = useMemo(() => abundancePercentFromT(t), [t]);
      const displayedPct = Math.min(abundancePct, 100);

      // Ease-in so chemi is "best channel" for longer
      const easedT = useMemo(() => Math.pow(t, 2.2), [t]);

      // Convert eased slider position to amplitude factor (keep your behavior)
      const abundanceFactor = useMemo(() => {
        const p = abundancePercentFromT(easedT);
        const logMin = Math.log10(0.001);
        const logMax = Math.log10(100);
        const u = (Math.log10(p) - logMin) / (logMax - logMin);
        return 0.03 + u * (3.0 - 0.03);
      }, [easedT]);

      // Move a and d together
      const a = 0.05 * abundanceFactor;
      const d = 1.00 * abundanceFactor;

      const xs = useMemo(() => logspace(xMin, xMax, 500), []);

      // Channel fixed properties (burnout ceilings fixed; LLOQs for NIR/IR will be auto-set)
      const channelBases = useMemo(
        () => [
          {
            key: "chemi",
            title: "Chemiluminescence",
            subtitle: "Highest sensitivity: best LLOQ, highest burnout risk",
            sensitivity: 1.45,
            yMinDetFixed: 0.05,
            yMaxSys: 0.90,
          },
          {
            key: "nir",
            title: "NIR",
            subtitle: "Medium sensitivity: can burn out in extreme cases",
            sensitivity: 0.65,
            yMinDet: 0.2,
            yMaxSys: 0.80,
          },
          {
            key: "ir",
            title: "IR",
            subtitle: "Lowest sensitivity: LLOQ is worse, burnout is rare",
            sensitivity: 0.24,
            yMaxSys: 1.25, // effectively "never burns out"
          },
        ],
        []
      );

      // Auto-calibrate NIR + IR LLOQ so the handovers happen in the right order.
      // We do this based on the signal at xHigh (high concentration end of the linear window).
      const calibratedChannels = useMemo(() => {
        // helper: compute amplitudeFactor for a hypothetical slider position tt (0..1)
        const ampAt = (tt) => {
          const et = Math.pow(tt, 2.2);
          const p = abundancePercentFromT(et);
          const logMin = Math.log10(0.001);
          const logMax = Math.log10(100);
          const u = (Math.log10(p) - logMin) / (logMax - logMin);
          return 0.03 + u * (3.0 - 0.03);
        };

        const chemi = channelBases.find((x) => x.key === "chemi");
        const nir = channelBases.find((x) => x.key === "nir");
        const ir = channelBases.find((x) => x.key === "ir");

        // Scan slider to find when chemi and nir start to burn at xHigh
        const N = 1001;
        let tChemiBurn = 1.0;
        let tNirBurn = 1.0;

        for (let i = 0; i < N; i++) {
          const tt = i / (N - 1);
          const amp = ampAt(tt);
          const aa = 0.05 * amp;
          const dd = 1.00 * amp;

          const yChemiHigh = fourPL(xHigh, aa, b, c, dd) * chemi.sensitivity;
          const yNirHigh = fourPL(xHigh, aa, b, c, dd) * nir.sensitivity;

          if (tChemiBurn === 1.0 && yChemiHigh >= chemi.yMaxSys) tChemiBurn = tt;
          if (tNirBurn === 1.0 && yNirHigh >= nir.yMaxSys) tNirBurn = tt;
        }

        // Targets:
        // NIR should become detectable shortly BEFORE chemi starts to burn
        // IR should become detectable shortly BEFORE NIR starts to burn
        const deltaNir = 0.06;
        const deltaIr = 0.05;

        const tNirDetectTarget = Math.max(0, tChemiBurn - deltaNir);
        const tIrDetectTarget = Math.max(0, tNirBurn - deltaIr);

        // Compute what the signal is at xHigh at those targets, and use that as the LLOQ
        // (so detection starts at high concentrations first, then expands)
        const ampN = ampAt(tNirDetectTarget);
        const aN = 0.05 * ampN;
        const dN = 1.00 * ampN;
        const nirLLOQ = fourPL(xHigh, aN, b, c, dN) * nir.sensitivity;

        const ampI = ampAt(tIrDetectTarget);
        const aI = 0.05 * ampI;
        const dI = 1.00 * ampI;
        const irLLOQ = fourPL(xHigh, aI, b, c, dI) * ir.sensitivity;

        // Add tiny padding so we avoid accidental overlap due to sampling granularity
        const nirLLOQPad = nirLLOQ * 1.02;
        const irLLOQPad = irLLOQ * 1.02;

        return channelBases.map((ch) => {
          if (ch.key === "chemi") return { ...ch, yMinDet: ch.yMinDetFixed };
          if (ch.key === "nir") return { ...ch, yMinDet: nirLLOQPad };
          if (ch.key === "ir") return { ...ch, yMinDet: irLLOQPad };
          return ch;
        });
      }, [channelBases, b, c, xHigh]);

      // Build per-panel curves and span shading
      const panels = useMemo(() => {
        return calibratedChannels.map((ch) => {
          const yTrue = xs.map((x) => fourPL(x, a, b, c, d) * ch.sensitivity);
          const yObs = yTrue.map((y) => clamp(y, ch.yMinDet, ch.yMaxSys));

          const idxBurn = yTrue.findIndex((y) => y >= ch.yMaxSys);
          const xCutBurn = idxBurn === -1 ? Infinity : (idxBurn === 0 ? xMin : xs[idxBurn]);

          const idxDet = yTrue.findIndex((y) => y >= ch.yMinDet);
          const xCutDet = idxDet === -1 ? Infinity : (idxDet === 0 ? xMin : xs[idxDet]);

          const spansBuilder = ({ x2px, y2px, plotW, plotH }) => (
            <>
              <rect
                x={0}
                y={y2px(ch.yMinDet)}
                width={plotW}
                height={y2px(0) - y2px(ch.yMinDet)}
                fill="currentColor"
                opacity="0.06"
              />

              {rectForXSpanLocal(
                Math.max(xLow, xCutDet),
                Math.min(xHigh, xCutBurn),
                x2px,
                plotH,
                "#66b3ff",
                0.18
              )}

              {xCutBurn < xHigh &&
                rectForXSpanLocal(
                  Math.max(xCutBurn, xLow),
                  xHigh,
                  x2px,
                  plotH,
                  "#ff9999",
                  0.25
                )}
            </>
          );

          return { ch, yTrue, yObs, spansBuilder };
        });
      }, [calibratedChannels, xs, a, b, c, d, xHigh, xLow, xMin]);

      // Suggested example based on when burnout begins
      const chemiPanel = panels.find((p) => p.ch.key === "chemi");
      const nirPanel = panels.find((p) => p.ch.key === "nir");

      const chemiBurning = chemiPanel ? chemiPanel.yTrue.some((y) => y >= chemiPanel.ch.yMaxSys) : false;
      const nirBurning = nirPanel ? nirPanel.yTrue.some((y) => y >= nirPanel.ch.yMaxSys) : false;

      const labelForAbundance = useMemo(() => {
        if (nirBurning) return "Recombinant protein (very abundant), IR-friendly";
        if (chemiBurning) return "Loading control (abundant), NIR-friendly";
        return "Phospho target (very low abundance), chemiluminescence-friendly";
      }, [chemiBurning, nirBurning]);

      return (
        <div className="w-full min-h-screen bg-gray-50 text-gray-900 p-4 text-base">
          <div className="max-w-[1600px] mx-auto">
            <h1 className="text-2xl font-semibold mb-3">Interactive Burnout and Sensitivity Visualiser</h1>

            <p className="text-sm mb-6 text-gray-700">
              The slider changes target abundance in the sample, which shifts both the lower plateau (a, background) and the upper plateau (d, max signal).
              Each detection channel has a different detection floor (LLOQ driver) and a different burnout ceiling (saturation driver).
            </p>

            <div className="bg-white rounded-2xl shadow p-4 mb-6">
              <div className="flex items-center gap-4 flex-wrap">
                <label className="text-lg font-semibold whitespace-nowrap">
                  Try samples with more or less abundant target
                </label>

                <input
                  type="range"
                  min={0}
                  max={1}
                  step={0.005}
                  value={t}
                  onChange={(e) => setT(parseFloat(e.target.value))}
                  className="w-full max-w-[760px]"
                />

                <div className="font-mono text-sm whitespace-nowrap">
                  The protein of interest represents{" "}
                  {displayedPct.toFixed(displayedPct >= 10 ? 0 : displayedPct >= 1 ? 2 : 4)}% of all proteins in your sample
                </div>

                <div className="text-sm text-gray-600 w-full mt-2">
                  Suggested example: <span className="font-medium">{labelForAbundance}</span>
                </div>
              </div>
            </div>

            <div className="grid grid-cols-12 gap-6 items-stretch">
              <div className="col-span-12 lg:col-span-3">
                <div className="bg-white rounded-2xl shadow p-4 h-full">
                  <div className="text-sm font-medium mb-3">Legend</div>
                  <ul className="space-y-3 text-sm">
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "rgba(0,0,0,0.06)" }} />
                      Below detection floor (not quantifiable)
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "#66b3ff", opacity: 0.18 }} />
                      Validated linear range (detectable)
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "#ff9999", opacity: 0.25 }} />
                      Lost due to burnout
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-10 border-t-4 border-dashed border-gray-900" />
                      Burnout threshold (channel-dependent)
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-10 border-t-4 border-dashed border-gray-900" style={{ borderTopStyle: "dotted" }} />
                      Detection floor (channel-dependent)
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-10 border-t-4 border-gray-900" />
                      Observed (after floor + ceiling)
                    </li>
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-10 border-t-4 border-dashed border-gray-900" style={{ borderTopWidth: 3 }} />
                      True assay response
                    </li>
                  </ul>

                  <div className="mt-5 text-xs text-gray-600 leading-relaxed">
                    Interpretation: a is baseline/background and d is max signal. Changing target abundance shifts both together in this simplified model.
                    Lower sensitivity channels have a higher detection floor, so LLOQ worsens.
                  </div>
                </div>
              </div>

              <div className="col-span-12 lg:col-span-9 grid grid-cols-1 xl:grid-cols-3 gap-6">
                {panels.map((p) => (
                  <Panel
                    key={p.ch.key}
                    title={p.ch.title}
                    subtitle={p.ch.subtitle}
                    pathsData={{ xs, yTrue: p.yTrue, yObs: p.yObs }}
                    spansBuilder={p.spansBuilder}
                    yMinDet={p.ch.yMinDet}
                    yMaxSys={p.ch.yMaxSys}
                    xAxisLabel="sample concentration (Î¼g/mL)"
                  />
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<Interactive4PLWidget />);
  </script>
</body>
</html>
