<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>4PL System Limit Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-50 text-gray-900">
  <div id="root" class="p-6"></div>

  <script type="text/babel" data-presets="react">
    const { useMemo, useState, useId } = React;

    function logspace(start, stop, num) {
      const arr = new Array(num);
      const logStart = Math.log10(start);
      const logStop = Math.log10(stop);
      for (let i = 0; i < num; i++) {
        const tt = i / (num - 1);
        arr[i] = Math.pow(10, logStart + tt * (logStop - logStart));
      }
      return arr;
    }

    function fourPL(x, a, b, c, d) {
      return a + (d - a) / (1 + Math.pow(c / x, b));
    }

    function linePath(xs, ys, x2px, y2px) {
      let d = "";
      for (let i = 0; i < xs.length; i++) {
        const X = x2px(xs[i]);
        const Y = y2px(ys[i]);
        d += i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`;
      }
      return d;
    }

    function makeX2pxLocal(xmin, xmax, plotW) {
      const logMin = Math.log10(xmin);
      const logMax = Math.log10(xmax);
      return (x) => {
        const v = (Math.log10(x) - logMin) / (logMax - logMin);
        return v * plotW;
      };
    }

    function makeY2pxLogLocal(yminPos, ymaxPos, plotH) {
      const lo = Math.log10(yminPos);
      const hi = Math.log10(ymaxPos);
      return (y) => {
        const yy = Math.max(y, yminPos);
        const v = (Math.log10(yy) - lo) / (hi - lo);
        return plotH - v * plotH;
      };
    }

    function rectForXSpanLocal(xStart, xEnd, x2px, plotH, fill, opacity) {
      if (!isFinite(xStart) || !isFinite(xEnd) || xEnd <= xStart) return null;
      const X1 = x2px(xStart);
      const X2 = x2px(xEnd);
      const x = Math.min(X1, X2);
      const w = Math.max(0, Math.abs(X2 - X1));
      return <rect x={x} y={0} width={w} height={plotH} fill={fill} opacity={opacity} />;
    }

    function clamp(y, lo, hi) {
      return Math.min(Math.max(y, lo), hi);
    }
    
    function abundanceFractionFromT(t) {
      const minF = 2e-5;
      const maxF = 0.05;
      const logMin = Math.log10(minF);
      const logMax = Math.log10(maxF);
      return Math.pow(10, logMin + t * (logMax - logMin));
    }

    function contiguousSpans(xs, mask) {
      const spans = [];
      let inRun = false;
      let runStart = 0;

      for (let i = 0; i < mask.length; i++) {
        if (mask[i] && !inRun) {
          inRun = true;
          runStart = i;
        }
        if ((!mask[i] || i === mask.length - 1) && inRun) {
          const endIdx = mask[i] ? i : i - 1;
          const xStart = xs[Math.max(0, runStart)];
          const xEnd = xs[Math.min(xs.length - 1, endIdx)];
          if (isFinite(xStart) && isFinite(xEnd) && xEnd > xStart) spans.push([xStart, xEnd]);
          inRun = false;
        }
      }
      return spans;
    }

    function fmtSci(x, sig = 2) {
      if (!isFinite(x) || x <= 0) return String(x);
      const e = Math.floor(Math.log10(x));
      const m = x / Math.pow(10, e);
      return `${m.toFixed(sig)}e${e >= 0 ? "+" : ""}${e}`;
    }

    function fmtTick(x) {
      if (!isFinite(x)) return String(x);
      if (x === 0) return "0";

      const ax = Math.abs(x);

      if (ax >= 0.01 && ax < 1000) {
        let decimals = 0;
        if (ax < 0.1) decimals = 2;
        else if (ax < 1) decimals = 1;
        else decimals = 0;

        const s = x.toFixed(decimals);
        return s.replace(/\.0+$/, "").replace(/(\.\d*[1-9])0+$/, "$1");
      }

      return fmtSci(x, 1);
    }

    function fmtPct(frac) {
      const pct = frac * 100;
      if (pct >= 1) return `${pct.toFixed(1)}%`;
      if (pct >= 0.01) return `${pct.toFixed(3)}%`;
      return `${pct.toExponential(2)}%`;
    }

    function nirGainFromT(t) {
      const minG = 1 / 500;
      const maxG = 1 / 2;
      const logMin = Math.log10(minG);
      const logMax = Math.log10(maxG);
      return Math.pow(10, logMin + t * (logMax - logMin));
    }

    function xHalfDecadesFromT(t) {
      return 0.8 + t * (3.0 - 0.8);
    }

    // 1-2-5 ticks per decade
    function logTicks125(min, max) {
      if (!(min > 0) || !(max > 0) || max <= min) return [];
      const ticks = [];
      const multipliers = [1, 2, 5];
      const eMin = Math.floor(Math.log10(min));
      const eMax = Math.ceil(Math.log10(max));
      for (let e = eMin; e <= eMax; e++) {
        const base = Math.pow(10, e);
        for (const m of multipliers) {
          const v = m * base;
          if (v >= min && v <= max) ticks.push(v);
        }
      }
      ticks.sort((a, b) => a - b);
      const out = [];
      for (const v of ticks) {
        if (out.length === 0 || Math.abs(Math.log10(v) - Math.log10(out[out.length - 1])) > 1e-6) out.push(v);
      }
      return out;
    }

    // Reduce graph width ~50% by shrinking SVG coordinate width
    const WIDTH = 520;

    function ChannelRow({
      ch,
      xs,
      yTrue,
      yObs,
      spansBuilder,
      yMinDet,
      yMaxSys,
      xMin,
      xMax,
      yDomainLog,
      showXAxis,
      xAxisLabel,
      yAxisLabel,
      rowH,
    }) {
      const clipId = useId();

      // Single knob: negative = move everything left, positive = right
      const xShift = -Math.min(200, WIDTH * 0.25);

      // Layout
      const rowLeftMargin = 16 + 110;
      const rowRightMargin = 16 + 14;
      const rowTopMargin = 10;
      const rowBottomMargin = showXAxis ? 54 : 18;

      const plotW = WIDTH - rowLeftMargin - rowRightMargin;
      const plotH = rowH - rowTopMargin - rowBottomMargin;

      // Apply shift consistently
      const plotX = rowLeftMargin + xShift;
      const plotY = rowTopMargin;

      const x2px = useMemo(() => makeX2pxLocal(xMin, xMax, plotW), [xMin, xMax, plotW]);
      const y2px = useMemo(
        () => makeY2pxLogLocal(yDomainLog.yMinPos, yDomainLog.yMaxPos, plotH),
        [yDomainLog, plotH]
      );

      const truePath = useMemo(() => linePath(xs, yTrue, x2px, y2px), [xs, yTrue, x2px, y2px]);
      const obsPath = useMemo(() => linePath(xs, yObs, x2px, y2px), [xs, yObs, x2px, y2px]);

      const xTicks = useMemo(() => logTicks125(xMin, xMax), [xMin, xMax]);

      return (
        <div className="relative">
          <svg
            viewBox={`0 0 ${WIDTH} ${rowH}`}
            width="100%"
            height={rowH}
            className="w-full block"
            preserveAspectRatio="xMidYMid meet"
          >
            <defs>
              {/* IMPORTANT: clip rect is in user space, so it must include plotX/plotY */}
              <clipPath id={clipId} clipPathUnits="userSpaceOnUse">
                <rect x={plotX} y={plotY} width={plotW} height={plotH} rx="8" ry="8" />
              </clipPath>
            </defs>

            {/* Channel label moves with the plot */}
            <text
              x={18 + xShift}
              y={plotY + plotH / 2}
              textAnchor="start"
              fontSize="22"
              fontWeight="600"
              fill="currentColor"
              opacity="0.95"
              dominantBaseline="middle"
            >
              {ch.shortLabel}
            </text>

            {/* Y axis title moves AND rotates around the shifted pivot */}
            <text
              x={92 + xShift}
              y={plotY + plotH / 2}
              textAnchor="middle"
              fontSize="14"
              fill="currentColor"
              opacity="0.85"
              transform={`rotate(-90, ${92 + xShift}, ${plotY + plotH / 2})`}
            >
              {yAxisLabel}
            </text>

            {/* Plot (clipped in user space) */}
            <g clipPath={`url(#${clipId})`}>
              <g transform={`translate(${plotX},${plotY})`}>
                {spansBuilder({ x2px, y2px, plotW, plotH })}

                {/* Detection floor */}
                <line
                  x1={0}
                  x2={plotW}
                  y1={y2px(yMinDet)}
                  y2={y2px(yMinDet)}
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeDasharray="2 6"
                  strokeLinecap="butt"
                  opacity="0.8"
                />

                {/* Burnout threshold */}
                <line
                  x1={0}
                  x2={plotW}
                  y1={y2px(yMaxSys)}
                  y2={y2px(yMaxSys)}
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeDasharray="6 6"
                  strokeLinecap="butt"
                />

                {/* True response */}
                <path
                  d={truePath}
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeDasharray="4 4"
                  strokeLinecap="butt"
                />

                {/* Observed response */}
                <path
                  d={obsPath}
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="3"
                  strokeLinecap="butt"
                />
              </g>
            </g>

            {/* X axis ticks + label only on bottom row */}
            {showXAxis ? (
              <g transform={`translate(${plotX},${plotY})`}>
                {xTicks.map((xt, i) => {
                  const X = x2px(xt);
                  return (
                    <g key={i} transform={`translate(${X}, ${plotH})`}>
                      <line x1={0} x2={0} y1={0} y2={6} stroke="currentColor" opacity="0.5" />
                      <text
                        x={0}
                        y={20}
                        textAnchor="middle"
                        fontSize="12"
                        fill="currentColor"
                        opacity="0.8"
                      >
                        {fmtTick(xt)}
                      </text>
                    </g>
                  );
                })}

                <text
                  x={plotW / 2}
                  y={plotH + 44}
                  textAnchor="middle"
                  fontSize="18"
                  fill="currentColor"
                  opacity="0.90"
                >
                  {xAxisLabel}
                </text>
              </g>
            ) : null}
          </svg>

          {/* Subtitle stays pinned to the panel edge (does not overlap plot) */}
          <div className="absolute top-2 right-3 text-xs text-gray-600 max-w-[420px] text-right">
            <span className="font-medium text-gray-800">{ch.title}</span>
            <span className="text-gray-600">: {ch.subtitle}</span>
          </div>
        </div>
      );
    }

    function StackedPanel({
      xs,
      panels,
      burnoutY,
      xMin,
      xMax,
      yDomainLog,
      xAxisLabel,
      yAxisLabel,
      rowH,
    }) {
      return (
        <div className="relative bg-white rounded-2xl shadow p-3">
          <div className="rounded-xl overflow-hidden">
            {panels.map((p, idx) => (
              <div key={p.ch.key} className={idx === 0 ? "" : "border-t border-gray-100"}>
                <ChannelRow
                  ch={p.ch}
                  xs={xs}
                  yTrue={p.yTrue}
                  yObs={p.yObs}
                  spansBuilder={p.spansBuilder}
                  yMinDet={p.ch.yMinDet}
                  yMaxSys={burnoutY}
                  xMin={xMin}
                  xMax={xMax}
                  yDomainLog={yDomainLog}
                  showXAxis={idx === panels.length - 1}
                  xAxisLabel={xAxisLabel}
                  yAxisLabel={yAxisLabel}
                  rowH={rowH}
                />
              </div>
            ))}
          </div>
        </div>
      );
    }

    function Interactive4PLWidget() {
      // Pro mode toggle
      const [pro, setPro] = useState(false);

      const [t, setT] = useState(0.703);

      // Blue band slope control
      const fixedMinSlope = 0.10;
      const [maxSlope, setMaxSlope] = useState(1.34);

      // Global system ceiling (absolute units)
      const [burnoutY, setBurnoutY] = useState(0.7);

      // X span and NIR gain
      const [xSpanT, setXSpanT] = useState(0.02027);
      const [nirGainT, setNirGainT] = useState(0.616);

      // 4PL shape parameters
      const b = 1.35;
      const c = 1e-3; // adjust all channels sensitivity here

      const abundanceFrac = useMemo(() => abundanceFractionFromT(t), [t]);
      const abundancePctStr = useMemo(() => fmtPct(abundanceFrac), [abundanceFrac]);

      // Constant baseline
      const a0 = 0.025;
      const d0 = 2.5;

      // X domain
      const xCenterLog10 = -0.5;
      const xHalfDec = useMemo(() => xHalfDecadesFromT(xSpanT), [xSpanT]);
      const xMin = useMemo(() => Math.pow(10, xCenterLog10 - xHalfDec), [xHalfDec]);
      const xMax = useMemo(() => Math.pow(10, xCenterLog10 + xHalfDec), [xHalfDec]);

      const xs = useMemo(() => logspace(xMin, xMax, 700), [xMin, xMax]);

      const slopeBand = useMemo(() => {
        const mx = Math.max(maxSlope, fixedMinSlope + 0.01);
        return { min: fixedMinSlope, max: mx };
      }, [maxSlope]);

      const nirTargetGain = useMemo(() => nirGainFromT(nirGainT), [nirGainT]);
      const irTargetGain = useMemo(() => nirTargetGain * nirTargetGain, [nirTargetGain]);

      const channels = useMemo(
        () => [
          {
            key: "chemi",
            shortLabel: "Chemi",
            title: "Chemiluminescence",
            subtitle: "Highest sensitivity, but saturates early",
            targetGain: 1.0,
            signalGain: 1.0,
            yMinDet: 0.03,
          },
          {
            key: "nir",
            shortLabel: "NIR",
            title: "NIR",
            subtitle: "Lower sensitivity, but extends usable range for loading controls",
            targetGain: nirTargetGain,
            signalGain: 1.0,
            yMinDet: 0.03,
          },
          {
            key: "ir",
            shortLabel: "IR",
            title: "IR",
            subtitle: "Very low sensitivity, suited for high-abundance or recombinant targets",
            targetGain: irTargetGain,
            signalGain: 1.0,
            yMinDet: 0.03,
          },
        ],
        [nirTargetGain, irTargetGain]
      );

      // Y domain (absolute units)
      const yDomainLog = useMemo(() => ({ yMinPos: 0.02, yMaxPos: 2.5 }), []);

      const panels = useMemo(() => {
        const EPS = 1e-12;

        return channels.map((ch) => {
          const yBase = xs.map(() => a0);

          const yTrue = xs.map((xTotal, i) => {
            const xTargetEff = Math.max(1e-16, abundanceFrac * xTotal * ch.targetGain);
            const a = yBase[i];
            const d = d0;

            const yRaw = fourPL(xTargetEff, a, b, c, d);
            const yScaled = a + (yRaw - a) * ch.signalGain;
            return yScaled;
          });

          const yObs = yTrue.map((y) => clamp(y, ch.yMinDet, burnoutY));

          const idxBurn = yTrue.findIndex((y) => y >= burnoutY);
          const xCutBurn = idxBurn === -1 ? Infinity : xs[Math.max(0, idxBurn)];

          const logX = xs.map((x) => Math.log10(x));
          const yNet = yTrue.map((y, i) => Math.max(EPS, y - yBase[i]));
          const logY = yNet.map((yn) => Math.log10(yn));

          const slope = new Array(xs.length).fill(NaN);
          for (let i = 1; i < xs.length - 1; i++) {
            const dLogX = logX[i + 1] - logX[i - 1];
            if (Math.abs(dLogX) < 1e-12) continue;
            slope[i] = (logY[i + 1] - logY[i - 1]) / dLogX;
          }
          slope[0] = slope[1];
          slope[slope.length - 1] = slope[slope.length - 2];

          const isBlue = xs.map((xTotal, i) => {
            const withinSignal = (yTrue[i] >= ch.yMinDet) && (yTrue[i] < burnoutY);
            const withinSlope = (slope[i] >= slopeBand.min) && (slope[i] <= slopeBand.max);
            const beforeBurn = !(xCutBurn < Infinity && xTotal >= xCutBurn);
            return withinSignal && withinSlope && beforeBurn;
          });

          const blueSpans = contiguousSpans(xs, isBlue);

          const spansBuilder = ({ x2px, y2px, plotW, plotH }) => (
            <>
              <rect
                x={0}
                y={y2px(ch.yMinDet)}
                width={plotW}
                height={y2px(yDomainLog.yMinPos) - y2px(ch.yMinDet)}
                fill="currentColor"
                opacity="0.06"
              />

              {blueSpans.map(([xA, xB], k) => (
                <React.Fragment key={k}>
                  {rectForXSpanLocal(xA, xB, x2px, plotH, "#66b3ff", 0.18)}
                </React.Fragment>
              ))}

              {xCutBurn < xMax &&
                rectForXSpanLocal(
                  Math.max(xCutBurn, xMin),
                  xMax,
                  x2px,
                  plotH,
                  "#ff9999",
                  0.25
                )}
            </>
          );

          return { ch, yTrue, yObs, spansBuilder };
        });
      }, [
        channels,
        xs,
        a0,
        d0,
        b,
        c,
        abundanceFrac,
        slopeBand,
        burnoutY,
        xMin,
        xMax,
        yDomainLog
      ]);

      const labelForAbundance = useMemo(() => {
        if (abundanceFrac >= 0.03)
          return "Extremely abundant (HSP60, HSP70, HSP90) (3.000% to 5.000%)";
        if (abundanceFrac >= 0.01)
          return "Very abundant, housekeeper range (β-Actin, α/β-Tubulin, GAPDH) (1.000% to 3.000%)";
        if (abundanceFrac >= 0.003)
          return "Abundant (metabolic enzymes, ribosomal proteins) (0.300% to 1.000%)";
        if (abundanceFrac >= 0.001)
          return "Moderate (ERK1/2, AKT, LDH) (0.100% to 0.300%)";
        if (abundanceFrac >= 0.0003)
          return "Low to moderate (STATs, SMADs, many kinases) (0.030% to 0.100%)";
        if (abundanceFrac >= 0.0001)
          return "Low, many signaling proteins (RAF, PI3K subunits, adaptor proteins) (0.010% to 0.030%)";
        if (abundanceFrac >= 0.00003)
          return "Very low (transcription factors, rare receptors) (0.003% to 0.010%)";
        return "Extremely low, phospho-like (p-AKT, p-ERK, transient PTMs) (0.001% to 0.003%)";
      }, [abundanceFrac]);


      const xUnit = "arb. loading units";
      const yUnit = "arb. signal units";

      const xAxisLabel = useMemo(() => `Total Sample Concentration (ex: μg/mL)`, []);
      const yAxisLabel = useMemo(() => `Measured Signal`, []);

      // Taller rows (kept)
      const rowH = 250;

      // When Pro is disabled: make ALL fonts relative to this slider much bigger (5x)
      // (This panel is the "relative to this slider" section.)
      const basicTextScale = pro ? "" : "text-[5rem] leading-[1.05]";

      return (
        <div className="w-full min-h-screen bg-gray-50 text-gray-900 p-4 text-base">
          <div className="max-w-[1600px] mx-auto">
            <div className="flex items-center justify-between gap-4 mb-3">
              <h1 className="text-2xl font-semibold">Interactive Burnout and Sensitivity Visualiser</h1>

              {/* Pro toggle button */}
              <button
                type="button"
                onClick={() => setPro((v) => !v)}
                className={
                  "px-4 py-2 rounded-xl text-sm font-semibold shadow-sm border transition " +
                  (pro
                    ? "bg-gray-900 text-white border-gray-900 hover:bg-gray-800"
                    : "bg-white text-gray-900 border-gray-200 hover:bg-gray-50")
                }
                aria-pressed={pro}
                title={pro ? "Pro mode enabled" : "Pro mode disabled"}
              >
                Pro: {pro ? "On" : "Off"}
              </button>
            </div>

            <div className="bg-white rounded-2xl shadow p-4 mb-6">
              <div className="grid grid-cols-12 gap-4 items-center">
                {/* ALWAYS VISIBLE: Target fraction slider */}
                <div className="col-span-12">
                  <div className={"font-medium mb-2 " + (pro ? "text-sm" : basicTextScale)}>
                    Target fraction inside the loaded sample
                  </div>
                  <input
                    type="range"
                    min={0}
                    max={1}
                    step={0.005}
                    value={t}
                    onChange={(e) => setT(parseFloat(e.target.value))}
                    className={"w-full " + (pro ? "" : "h-10")}
                  />
                  <div
                    className={
                      "mt-2 text-gray-700 " +
                      (pro ? "text-sm" : "text-[1.7rem] leading-[1.1]")
                    }
                  >
                    <span className="text-gray-600">Order-of-magnitude estimate: </span>
                    <span className="font-medium">{labelForAbundance}</span>
                  </div>
                </div>

                {/* PRO-ONLY: ALL THE OTHER SLIDERS (unchanged features) */}
                {pro ? (
                  <>
                    <div className="col-span-12 lg:col-span-6">
                      <div className="text-sm font-medium mb-2">Linearity band (blue): expand to the left</div>
                      <input
                        type="range"
                        min={1.05}
                        max={1.34}
                        step={0.005}
                        value={maxSlope}
                        onChange={(e) => setMaxSlope(parseFloat(e.target.value))}
                        className="w-full"
                      />
                      <div className="mt-2 text-sm text-gray-700">
                        Slope band: <span className="font-mono">{(0.10).toFixed(2)} to {Math.max(maxSlope, 0.11).toFixed(2)}</span>
                        <span className="text-gray-600"> (higher max lets blue extend left)</span>
                      </div>
                    </div>

                    <div className="col-span-12 lg:col-span-6">
                      <div className="text-sm font-medium mb-2">Burnout threshold (all channels)</div>
                      <input
                        type="range"
                        min={0.20}
                        max={1.40}
                        step={0.01}
                        value={burnoutY}
                        onChange={(e) => setBurnoutY(parseFloat(e.target.value))}
                        className="w-full"
                      />
                      <div className="mt-2 text-sm text-gray-700">
                        Burnout y: <span className="font-mono">{burnoutY.toFixed(2)}</span> <span className="text-gray-600">{yUnit}</span>
                      </div>
                    </div>

                    <div className="col-span-12 lg:col-span-6">
                      <div className="text-sm font-medium mb-2">X-axis span (all channels)</div>
                      <input
                        type="range"
                        min={0}
                        max={1}
                        step={0.005}
                        value={xSpanT}
                        onChange={(e) => setXSpanT(parseFloat(e.target.value))}
                        className="w-full"
                      />
                      <div className="mt-2 text-sm text-gray-700">
                        X range: <span className="font-mono">{fmtSci(xMin, 1)} to {fmtSci(xMax, 1)}</span>
                        <span className="text-gray-600"> {xUnit}</span>
                      </div>
                    </div>

                    <div className="col-span-12">
                      <div className="text-sm font-medium mb-2">NIR targetGain (IR = NIR²)</div>
                      <input
                        type="range"
                        min={0}
                        max={1}
                        step={0.005}
                        value={nirGainT}
                        onChange={(e) => setNirGainT(parseFloat(e.target.value))}
                        className="w-full"
                      />
                      <div className="mt-2 text-sm text-gray-700">
                        NIR targetGain: <span className="font-mono">{fmtSci(nirTargetGain, 2)}</span>
                        <span className="text-gray-600">  </span>
                        IR targetGain: <span className="font-mono">{fmtSci(irTargetGain, 2)}</span>
                        <span className="text-gray-600">  </span>
                        (Chemi targetGain is 1.00)
                      </div>
                    </div>
                  </>
                ) : null}
              </div>
            </div>

            <div className="grid grid-cols-12 gap-6 items-stretch">
              {/* Left legend panel */}
              <div className="col-span-12 lg:col-span-3">
                <div className="bg-white rounded-2xl shadow p-4 h-full">
                  <div className="text-sm font-medium mb-3">Legend</div>

                  <ul className="space-y-3 text-sm">
                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "rgba(0,0,0,0.06)" }} />
                      Below detection floor (not quantifiable)
                    </li>

                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "#66b3ff", opacity: 0.18 }} />
                      Slope-based linear region (computed from baseline-subtracted signal)
                    </li>

                    <li className="flex items-center gap-3">
                      <span className="inline-block w-4 h-4 rounded" style={{ background: "#ff9999", opacity: 0.25 }} />
                      Burnout region (do not use)
                    </li>

                    <li className="flex items-center gap-3">
                      <svg width="44" height="12" className="block">
                        <line x1="0" y1="6" x2="44" y2="6" stroke="currentColor" strokeWidth="1.5" strokeDasharray="6 6" />
                      </svg>
                      Burnout threshold
                    </li>

                    <li className="flex items-center gap-3">
                      <svg width="44" height="12" className="block">
                        <line x1="0" y1="6" x2="44" y2="6" stroke="currentColor" strokeWidth="1.5" strokeDasharray="2 6" opacity="0.9" />
                      </svg>
                      Detection floor
                    </li>

                    <li className="flex items-center gap-3">
                      <svg width="44" height="12" className="block">
                        <line x1="0" y1="6" x2="44" y2="6" stroke="currentColor" strokeWidth="3" />
                      </svg>
                      Observed (after floor + burnout)
                    </li>

                    <li className="flex items-center gap-3">
                      <svg width="44" height="12" className="block">
                        <line x1="0" y1="6" x2="44" y2="6" stroke="currentColor" strokeWidth="1.5" strokeDasharray="4 4" />
                      </svg>
                      True assay response
                    </li>
                  </ul>
                </div>
              </div>

              {/* Right stacked graphs */}
              <div className="col-span-12 lg:col-span-9">
                <StackedPanel
                  xs={xs}
                  panels={panels}
                  burnoutY={burnoutY}
                  xMin={xMin}
                  xMax={xMax}
                  yDomainLog={yDomainLog}
                  xAxisLabel={xAxisLabel}
                  yAxisLabel={yAxisLabel}
                  rowH={rowH}
                />
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<Interactive4PLWidget />);
  </script>
</body>
</html>






